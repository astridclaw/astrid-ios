import Foundation

/**
 * OAuth Manager for iOS
 *
 * Handles OAuth 2.0 client credentials flow for the iOS app.
 * Automatically manages token lifecycle (generation, refresh, expiration).
 */
class OAuthManager {
    static let shared = OAuthManager()

    // OAuth Configuration
    private struct OAuthConfig {
        // OAuth Client Credentials (generated by setup-ios-oauth script)
        static let clientId = "astrid_client_be2300aa9f034889e836ba0efc9c5e8d"
        static let clientSecret: String = {
            // Load from keychain (stored during first run)
            if let secret = KeychainService.shared.getOAuthClientSecret() {
                return secret
            }
            // Fallback - should be set during app first run
            return ""
        }()
        static let scopes = [
            "tasks:read",
            "tasks:write",
            "tasks:delete",
            "lists:read",
            "lists:write",
            "lists:delete",
            "lists:manage_members",
            "comments:read",
            "comments:write",
            "comments:delete",
            "attachments:read",
            "attachments:write",
            "attachments:delete",
            "user:read",
            "user:write",
            "public:read",
            "public:write"
        ]
    }

    // Token state
    private var accessToken: String?
    private var tokenExpiresAt: Date?
    private var isRefreshing = false
    private var refreshCallbacks: [(Result<String, Error>) -> Void] = []

    // Configuration
    private let baseURL: URL
    private let session: URLSession

    private init() {
        self.baseURL = URL(string: Constants.API.baseURL)!

        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = Constants.API.timeout
        self.session = URLSession(configuration: configuration)

        // Try to load cached token
        loadCachedToken()
    }

    // MARK: - Public API

    /**
     * Get a valid access token
     * Automatically refreshes if expired or about to expire
     */
    func getAccessToken() async throws -> String {
        // Check if we have a valid cached token
        if let token = accessToken,
           let expiresAt = tokenExpiresAt,
           expiresAt > Date().addingTimeInterval(60) { // 1 min buffer
            return token
        }

        // Prevent concurrent refresh requests
        if isRefreshing {
            return try await waitForRefresh()
        }

        // Refresh the token
        return try await refreshAccessToken()
    }

    /**
     * Configure OAuth credentials
     * Should be called after user signs in for the first time
     */
    func configure(clientSecret: String) {
        KeychainService.shared.saveOAuthClientSecret(clientSecret)
    }

    /**
     * Clear all OAuth credentials
     * Call on logout
     */
    func clearCredentials() {
        accessToken = nil
        tokenExpiresAt = nil
        KeychainService.shared.deleteOAuthClientSecret()
        clearCachedToken()
    }

    // MARK: - Token Management

    private func refreshAccessToken() async throws -> String {
        isRefreshing = true
        defer { isRefreshing = false }

        print("üîê [OAuthManager] Refreshing access token...")

        // Check if we have credentials
        let clientSecret = OAuthConfig.clientSecret
        if clientSecret.isEmpty {
            print("‚ùå [OAuthManager] No client secret found in Keychain!")
            print("‚ö†Ô∏è [OAuthManager] OAuth secret must be configured. Call OAuthManager.shared.configure(clientSecret:)")
            throw OAuthError.noCredentials
        }

        print("‚úÖ [OAuthManager] Client secret found, requesting token...")

        let endpoint = baseURL.appendingPathComponent("/api/v1/oauth/token")
        var request = URLRequest(url: endpoint)
        request.httpMethod = "POST"
        request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")

        // Build request body
        var components = URLComponents()
        components.queryItems = [
            URLQueryItem(name: "grant_type", value: "client_credentials"),
            URLQueryItem(name: "client_id", value: OAuthConfig.clientId),
            URLQueryItem(name: "client_secret", value: clientSecret),
            URLQueryItem(name: "scope", value: OAuthConfig.scopes.joined(separator: " "))
        ]
        request.httpBody = components.query?.data(using: .utf8)

        do {
            let (data, response) = try await session.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse else {
                throw OAuthError.invalidResponse
            }

            if httpResponse.statusCode == 401 {
                print("‚ùå [OAuthManager] Invalid credentials")
                throw OAuthError.invalidCredentials
            }

            guard httpResponse.statusCode == 200 else {
                let errorMsg = String(data: data, encoding: .utf8) ?? "Unknown error"
                print("‚ùå [OAuthManager] Token request failed: \(errorMsg)")
                throw OAuthError.requestFailed(httpResponse.statusCode)
            }

            let tokenResponse = try JSONDecoder().decode(OAuthTokenResponse.self, from: data)

            // Cache the token
            accessToken = tokenResponse.accessToken
            tokenExpiresAt = Date().addingTimeInterval(TimeInterval(tokenResponse.expiresIn))

            // Persist to disk for next app launch
            cacheToken(token: tokenResponse.accessToken, expiresAt: tokenExpiresAt!)

            print("‚úÖ [OAuthManager] Access token obtained (expires in \(tokenResponse.expiresIn)s)")

            // Notify any waiting callers
            notifyRefreshCallbacks(.success(tokenResponse.accessToken))

            return tokenResponse.accessToken

        } catch {
            print("‚ùå [OAuthManager] Token refresh failed: \(error)")
            notifyRefreshCallbacks(.failure(error))
            throw error
        }
    }

    private func waitForRefresh() async throws -> String {
        return try await withCheckedThrowingContinuation { continuation in
            refreshCallbacks.append { result in
                continuation.resume(with: result)
            }
        }
    }

    private func notifyRefreshCallbacks(_ result: Result<String, Error>) {
        let callbacks = refreshCallbacks
        refreshCallbacks.removeAll()

        for callback in callbacks {
            callback(result)
        }
    }

    // MARK: - Token Caching

    private func cacheToken(token: String, expiresAt: Date) {
        let cacheData: [String: Any] = [
            "token": token,
            "expiresAt": expiresAt.timeIntervalSince1970
        ]

        if let data = try? JSONSerialization.data(withJSONObject: cacheData) {
            UserDefaults.standard.set(data, forKey: "oauth_token_cache")
        }
    }

    private func loadCachedToken() {
        guard let data = UserDefaults.standard.data(forKey: "oauth_token_cache"),
              let cacheData = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let token = cacheData["token"] as? String,
              let expiresAtTimestamp = cacheData["expiresAt"] as? TimeInterval else {
            return
        }

        let expiresAt = Date(timeIntervalSince1970: expiresAtTimestamp)

        // Only use cached token if still valid
        if expiresAt > Date() {
            accessToken = token
            tokenExpiresAt = expiresAt
            print("‚úÖ [OAuthManager] Loaded cached token (expires at \(expiresAt))")
        } else {
            print("‚è∞ [OAuthManager] Cached token expired, will refresh on next request")
            clearCachedToken()
        }
    }

    private func clearCachedToken() {
        UserDefaults.standard.removeObject(forKey: "oauth_token_cache")
    }
}

// MARK: - Response Models

struct OAuthTokenResponse: Codable {
    let accessToken: String
    let tokenType: String
    let expiresIn: Int
    let scope: String

    enum CodingKeys: String, CodingKey {
        case accessToken = "access_token"
        case tokenType = "token_type"
        case expiresIn = "expires_in"
        case scope
    }
}

// MARK: - Errors

enum OAuthError: LocalizedError {
    case noCredentials
    case invalidCredentials
    case invalidResponse
    case requestFailed(Int)

    var errorDescription: String? {
        switch self {
        case .noCredentials:
            return "OAuth credentials not configured. Please sign in again."
        case .invalidCredentials:
            return "Invalid OAuth credentials. Please sign in again."
        case .invalidResponse:
            return "Invalid response from authentication server"
        case .requestFailed(let code):
            return "Authentication failed with code: \(code)"
        }
    }
}
